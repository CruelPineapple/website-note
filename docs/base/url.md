# 输入url后

大致分为这么几个阶段：

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 返回HTTP报文
5. 浏览器渲染界面

## DNS解析

（其实最开始会检查浏览器和本机系统的缓存，有没有这个域名对应的IP）

例如查询www.google.com

首先查询域名的请求会来到本地DNS服务器（运营商提供），如果本地DNS服务器没有此域名的IP地址，它就会先向根域名服务器查询

根域名服务器也不知道这个域名的IP地址，但是它告诉了本地DNS服务器，管理com这个顶级域名的DNS服务器的IP

于是本地DNS服务器再次询问com顶级域名服务器，com域名服务器也不知道这个域名的具体IP，于是返回了管理google.com这个域的域名服务器地址

本地DNS服务器再次询问管理google.com域名的DNS服务器，这次得到了www.google.com对应的IP地址，于是本地DNS服务器将这个IP返回给客户端（并缓存这个解析结果，如果有其他请求询问www.google.com，本地DNS服务器就能直接回答了）

## TCP连接

HTTP的话在三次握手那篇（包括慢启动，拥塞控制），TLS连接在HTTPS那里

## 解析页面

MDN提到慢启动第一个数据包是14kb，因此在前14kb包含浏览器开始渲染的所有内容对于优化来说是十分重要的。

### 构建DOM树

浏览器首先解析HTML标签并构造DOM树，这个过程中，图片和引用CSS的link标签都属于非阻塞资源，解析标签会继续进行。但是script标签会导致解析阻塞，浏览器会先加载script标签的内容再继续解析。

### 预加载扫描器

非阻塞资源由预加载扫描器发现并下载，例如有async或defer属性的script标签，图片和css。这个过程中，css加载会阻塞js，因为js可能会查询元素的css属性

在构建DOM树和CSSOM树的时候，已经下载好的js就可以开始创建AST（抽象语法树）了

### 构建CSSOM树

CSSOM，cssObject Model，CSS对象模型，就是CSS树。浏览器遍历所有CSS规则，根据选择器创建具有父子兄弟关系的节点树。构建CSSOM非常快

### 渲染

DOM和CSSOM组合成一个Render树，这时候例如head，script以及display：none样式的节点就不会出现在Render树中了（但是visibility：hedden还是会被加入render树的）。每个节点都会应用CSSOM的规则。

### Layout

接下来对渲染树进行布局计算，确定树中所有节点的宽高和位置。第一次确定了节点大小和位置称为布局，这时候节点会以盒子的形式被作为一个一个框框来布局。随后对节点大小和位置的重新计算称为回流，例如图像还未返回的时候，还没有声明它的大小，一旦知道了图像的大小就会出现回流。

### Paint

最后一步是将各节点绘制到屏幕上，布局阶段的每个框会被转换为屏幕的实际像素，这个阶段元素的每个可视部分会被绘制，如文本，颜色，边框等。这项工作需要非常快速，为了保证平滑地滚动或是流畅的动画，它必须在16.67ms内完成（60FPS中一帧之内的时间）。绘制过程可以将布局树中的元素分解为多个层，将内容提升到GPU（而不是CPU主线程）来提高性能

### 交互

主线程把页面绘制完成之后，还需要把js下载好并解析运行才能响应用户的交互
