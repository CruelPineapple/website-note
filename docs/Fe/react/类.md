# 类
从现在开始从头看React👀，这一篇是跟着react说的，需要先看的js内容，反正es6也没系统看过，就正好看了。

类是特殊的函数，是用于创建对象的模板。和定义函数表达式和函数声明类似，类也有两种定义方式，类表达式和类声明。

### 类声明

class关键字用于声明一个类，需要注意，类声明没有提升，与函数声明提升区别

### 类表达式

可以命名或者不命名，命名类表达式的名称是该类的局部名称，可以通过类的name属性来检索：

```js
// 未命名/匿名类
let Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// output: "Rectangle"

// 命名类
let Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
console.log(Rectangle.name);
// 输出: "Rectangle2"
```

## 类体和方法定义

类的主体，如构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。类的属性有name，公共属性（通过prototype定义的属性），实例属性（构造器在this上定义的）

### 构造函数

constructor方法，用于创建和初始化一个由class创建的对象，一个构造函数可以用super关键字调用一个父类的构造函数

这里补充介绍自有属性：出现在实例而非原型的属性，《深入理解es6》中建议在构造器中创建所有可能出现的自有属性，这样类中声明的变量就会被限制在一个位置从而便于检查

除非显式定义在this上的属性，其他属性都会在原型上

### 原型方法

es6的简化方法定义，可以直接在对象里面写函数作为方法：

```js
class Rectangle {
    // constructor
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    // Getter
    get area() {
        return this.calcArea()
    }
    // Method
    calcArea() {
        return this.height * this.width;
    }
}
const square = new Rectangle(10, 10);

console.log(square.area);
// 100
```

### 静态方法

static关键字定义的方法，不能通过实例调用该方法，只能通过类。调用静态方法不需要实例化该类，MDN通过一个例子给出了静态方法通常的用法：

```js
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    static displayName = "Point";

    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10,10);
p1.displayName;
// undefined
p1.distance;
// undefined

console.log(Point.displayName);
// "Point"
console.log(Point.distance(p1, p2));
// 7.0710678118654755
```

### 私有字段

使用#符号修饰的字段会作为私有字段，只能由本实例访问

### getter和setter

用于读取和操作字段的方法，例如封装私有字段：

```js
class User {
    #nameValue;

    constructor(name) {
        this.name = name;
    }

    get name() {
        return this.#nameValue;
    }

    set name(name) {
        if (name === "") {
            throw new Error(`name field of User cannot be empty`);
        }
        this.#nameValue = name;
    }
}

const user = new User("Fundebug");
user.name; // getter 被调用, => 'Fundebug'
user.name = "Code"; // setter 被调用

user.name = ""; // setter 抛出一个错误
```

getter和setter必须同时出现同级出现

## this绑定

由于原型方法和静态方法总是在严格模式运行，它们的this默认是undefined的