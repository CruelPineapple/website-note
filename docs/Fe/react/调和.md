# 协调（Reconciliation）

就是同步虚拟dom和dom节点的过程

递归对比树节点的复杂度是O（n3），但是react作出了一些假设进行优化：只比较同层级的节点，因为跨层级的dom操作不多。如果组件类型直接发生了变化，那就直接删除旧的，增加新的。同层级的节点可以通过设置key来进行标识，react会尽可能重用它们。

react15是基于栈进行调和的，它是一个同步的过程。当虚拟dom很大的时候，需要相当长的时间占用主线程进行递归的对比，导致渲染卡顿。

react16使用的fiber将长耗时的同步任务转换为多个短耗时的分片，配合scheduler对每个任务分配一个优先级，及时让出主线程。

高优先级的任务会尽快进入协调过程，对于新到达的任务，如果优先级比已经在协调的任务更高，就会进行中断，换成更高优先级的任务进入协调。

## render和commit

### render

render阶段react更新调用了setState或是render方法的组件，确定哪些节点需要更新或者删除，哪些节点需要调用生命周期方法，这些信息最终会被保存到一个叫effect list的fiber树上（会单独开篇学fiber树）。在首次渲染的时候，react不需要更新信息，而是为每个render方法返回的元素生成一个fiber节点，最终形成一个fiber树，后续更新也是复用的这棵树。

render是没有副作用的，react可以调度的任务都处于render阶段，这也是为什么它必须没有副作用，因为在调度中可能中断它并在未来某个时刻重新执行。

构建workInProgress fiber tree的过程就是在render阶段进行的

### commit

commit阶段中，react中有三棵fiber树：

- current fiber tree：首次渲染时根据每个render方法生成的fiber节点组成的树

- workInProgress fiber tree：更新工作中，会遍历current fiber tree，为每一个节点创建一个替代节点（可能和原来的节点相同），这些替代节点形成workInProgress fiber tree

- effect list fiber tree：workInProgress fiber tree的子树，保存workInProgress fiber tree中真正有更新的节点。

commit阶段的任务就是遍历effect list，把更新同步至DOM。

首先有一个pre-commit阶段，获取当前DOM的快照。接下来执行需要卸载组件的componentWillUnmount方法，接着根据effect list将current fiber tree替换为workInProgress fiber tree。最后根据current fiber tree修改DOM，为新增的节点执行componentDidMount，为更新的节点执行componentDidUpdate

