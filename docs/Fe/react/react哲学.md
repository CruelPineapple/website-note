# react哲学--锐评ASD

读了文档里面的[react哲学](https://zh-hans.reactjs.org/docs/thinking-in-react.html)，醍醐灌顶属于。今天先睡觉去了，小摆一手

## 通过UI划分组件层级

一个组件一般只负责一个功能，如果你发现了一个负责许多功能的组件，就应该考虑把它拆解为更小的组件。

组件的层级关系应该由UI的包含关系来确定。

一个恰当设计的软件模型中，UI和数据模型很容易就对应起来（它们会倾向于遵守相同的信息结构）

## 用React创建一个静态版本

先实现一个不包含交互功能的UI，在添加交互。这两个功能分开的好处在于：往往实现静态版本需要大量代码而不必考虑太多细节，添加交互的时候则需要考虑大量细节。

props是父组件向子组件传递数据的方式，state代表会随着时间变化的数据，因此静态内容都使用props。

文中建议，简单应用可以从高层级的组件开始；大型项目则最好从基础组件开始

## 确定UI state的最小完整表示

react通过state来触发数据模型改变。state最好是所需的最小表示，其它需要的数据可以通过已有的state计算得出。

通过这三个问题检查数据是否该属于state：

1. 该数据是不是从props传来的？如果是，它应该不是state
2. 该数据是否随着时间推移保持不变？如果是，它应该不是state
3. 该数据是否能根据其它props和state算出来，如果是，它应该不是state

## 确定state位置

react是单向数据流，自顶向下地传递。哪个组件拥有哪个state会比较难判断。

对于每一个state：

1. 找到根据这个state渲染的所有组件
2. 找到它们的共同父组件
3. 这个父组件或者更高层级的组件可以拥有这个state
4. 如果没有一个合适的位置存放state，可以考虑创建一个新组件来存放该state，这个新组件应该高于共同父组件的层级

## 添加反向数据流

例如一个开关，它被按下的时候，需要去调整其上层某个组件的state从而影响根据这个state渲染的组件。react通过传递回调函数给这个开关让其修改上层组件的值。

[React 哲学：第五步](https://codepen.io/gaearon/pen/LzWZvb)

观察demo是如何让数据反向流动的：

1. 需要被修改的state例如filterText在顶层的组件，修改它的组件是search
2. 顶层组件定义好修改的方法作onFilterTextChange为props传给search组件
3. search组件内为input标签绑定handleFilterTextChange方法用于处理input标签的onChange事件
4. 事件回调内调用props传来的onFilterTextChange，并将合成事件中的e.target.value作为参数

像这个demo所示，静态内容通过props自顶向下传，每个组件维护自己最小化的state

## 锐评ASD

学习了react哲学，让我来锐评一下没有学习react哲学的时候的作品：A-SOUL Digits

我的组件结构是简单且不合理的，是专注于实现功能的朴素组件思想。只对大块的功能进行了切分，也就是展示的盒子，盒子内部相似的组件都是没有复用的。

其次props使用也是非常不成熟的，推测由于之前更加不成熟的vue项目的影响，我习惯将组件所需的数据都加入data，到了react中就是state。我认为react的理念是正确的，需要变化的部分才存放在state。实际上，不管在哪种框架中，我认为都应该选用props作为静态数据传输的手段。

理清组件之间的逻辑是十分重要的，这也是我目前感到困难的地方。一个大型组件内部数据可以放的更自由一点，同时也应该注意可读性，不能混进去太多逻辑导致维护起来变得困难。

### 优化

第一个优化的是列表渲染，原先直接丢了五个HoverBox，现在新增一个函数组件BoxList，根据传入的props生成一个HoverBox列表。同时App.js也作出相应的修改，将原本state中的静态信息（成员信息列表）改成了普通js变量，最后将class组件改为函数组件（因为不再需要state了）

第二个优化的是HoverBox中state里的bgColor属性。这个属性的值一直等于props.name，因此应该将它变成一个计算属性

第三个优化的是网络请求。HoverBox中的方法应该专注于操作自己的state，因此抽取了所有网络请求方法到一个单独的文件Api.js内，每个请求方法都封装axios的调用，并返回这个调用。因为axios返回的是promise，所以在封装的方法上同样可以使用then方法。另外，由于本地调试接口需要走一遍代理，走代理的路径和部署后的请求路径是不一样的，Api.js中也将请求路径的这一段抽取出来统一处理了。

第四个优化的是背景图片，因为react不允许直接设置图片的src，HoverBox需要动态地设置背景图片是需要一个逻辑来进行设置的。这部分设置图片路径的逻辑被抽离到了Img.js中，暴露一个接受name属性的组件给HoverBox调用即可。

优化后的App就显得更加合理了，每个组件都有自己负责的逻辑，虽然没有达到《react哲学》文中那样细分的组件，但是至少目前，HoverBox只维护了必要的state，并且专注于修改自己的state，网络请求和动态图片背景等逻辑都独立成其它组件了。

需要注意的是，虽然抽了些组件出去，但是css内容始终在HoverBox.css内，react貌似是不隔离每个组件的css的

## css优化

写了一部分优化分配css类名的在ASD的hook练习里面
