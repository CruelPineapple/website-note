# V8

## Parser

进行词法分析，找出错误的语法，生成AST并确定词法作用域。它会解析所有立即执行的代码，发现不会被立即执行的代码，就会使用Pre-Parser对它解析

## Pre-Parser

只解析不被立即执行的代码（例如函数）不会生成AST，只确定作用域，以此提高性能

## Ignition

Ignition是v8引擎的字节码解释器，改善代码启动速度和网页加载速度。主要负责将AST转换为字节码（很快速），并逐行解释字节码，在这个阶段就已经开始执行代码了。

在使用Ignition之前，v8直接将js编译成机器码（为了机器码快速执行的能力）。然而机器码占用内存很大，不能一次性全部编译并缓存下来，所以只编译最外层的代码，函数内部的代码会被推迟到第一次被调用的时候再编译（惰性解析）。这还导致了代码需要被多次解析，而且闭包会让解析变得更复杂。

而Ignition将代码编译成字节码，字节码的空间占用比机器码小很多，就能提前编译所有代码了。同时编译成字节码的时间比编译成机器码的时间要短很多，因此代码启动的速度也会更快。

## TurboFan

对字节码的优化，v8使用TurboFan。Ignition在执行代码的时候，v8会一直观察代码的执行情况👀，着重关注每个函数的执行次数，传递参数类型等等。对于高频函数，会被标记为热点代码，并将其对应的字节码交给TurboFan。TurboFan会根据执行信息做一些假设（因为执行环境是动态的，需要假设一下才能生成机器码）并把字节码编译成优化后的机器码，在后续再次调用该函数的时候，如果符合生成的时候做的假设条件，就会使用优化后的代码，提高性能。

如果假设不成立，例如传入参数突然发生了变化，表明TurboFan的假设错了，那这一段优化过的机器码就不能用了，就会进行优化回退，重新进行观察。

## 粗略过程

1. 源代码生成AST
   1. 词法解析，源码拆分为字段
   2. 语法解析，根据字段生成AST
2. 生成字节码
   1. Ignition根据AST生成字节码（Ignition详见单独篇）
   2. 字节码相比机器码，内存占用更少
3. 执行代码
   1. Ignition在执行代码的时候，发现热点代码，后台编译器TurboFan就把热点代码编译成高效机器码
   2. 再次执行这段代码就会执行热点代码对应的机器码
   3. Ignition和TurboFan结合形成JIT（即时编译）

babel将es6代码转换为es6的AST，再转换成ES5的AST。eslint先把代码转换为AST，通过AST检查代码规范