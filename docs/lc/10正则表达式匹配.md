# 10正则表达式匹配 dp

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'\*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

---

题目什么意思呢，就是说有一个字符串s，让咱们判断这个字符串s是不是符合一个特定的规律p。这个规律p中有两种特殊字符，'.'和'\*' 。通常情况下，字符串s和字符规律p的对应位置必须要相同才能认为它们是匹配的，但是有了 '.'和'\*'，匹配规则就可以变通一下了：

* '.'表示这个位置可以匹配任何一个字符
* '\*'表示规律中前一个字符可以出现任意次（也可以不出现）

由于'\*'影响的是前一个字符，从后往前匹配会更加便于判断。

## 动态规划解法

用 i，j 分别表示字符串 s 和字符规律 p 的长度，要使 s(0, i) 和 p(0, j) 匹配，需要其子串 s(0, i - 1)，p(0, j - 1)匹配，同时 s[i - 1] === p[j - 1]。这是递归的基本思路，下面细分具体情况

### s[i−1] 和 p[j−1] 匹配

这时候问题就转化为剩余子串匹配的答案，即考察 s(0, i - 2)，p(0, j - 2) 匹配情况

### s[i−1] 和 p[j−1] 不匹配

不匹配也分为两种情况：p[j - 1] 是'\*'；p[j - 1] 不是'\*'

#### 如果p[j - 1]是'\*'

此时考察 s[i - 1] 和 p[j - 2] 的匹配情况。不论该字符匹配情况如何，都是有可能使 s 和 p 匹配的

#####s[i - 1] 和 p[j - 2] 匹配

p[j - 1]是'\*'，s[i - 1] 和 p[j - 2] 匹配，此时有三种情况：

p[j - 1]的'\*'使 p[j - 2] 的字符在 s 中匹配 0 次，1 次和两次以上，只要其中任意一种情况的子串能够匹配，那么就可以匹配

* p[j - 2] 重复 0 次，此时问题转化为求解 s(0, i - 1) 和 p(0, j - 3) 的匹配情况
* p[j - 2] 重复 1 次，此时问题转化为求解 s(0, i - 2) 和 p(0, j - 3) 的匹配情况
* p[j - 2] 重复 2 次及以上，此时问题转化为求解 s(0, i - 2) 和 p(0, j - 1) 的匹配情况。此种情况重复使用 p(0, j - 1) 进行匹配，直到p[j - 2] 重复次数小于2，最终转化成前两种情况

##### s[i - 1] 和 p[j - 2] 不匹配

p[j - 1]是'\*'，s[i - 1] 和 p[j - 2] 匹配，仍然有匹配的可能，令 p[j - 1]的'\*' 使其前一个字符出现 0 次即可，此时问题转化为求解 s(0, i - 1) 和 p(0, j - 3) 的匹配情况，和上面 **s[i - 1] 和 p[j - 2] 匹配**的第一种情况相同。

### 基本情况

- p 为空串，s 不为空串，不匹配。
- s 为空串，但p 不为空串，要想匹配，p 只可能是一个字符 + '\*' 的组合
- s、p 都为空串，匹配

### 代码

照例在后面进行分析

```javascript
const isMatch = (s, p) => {
  if (s == null || p == null) return false;

  const sLen = s.length, pLen = p.length;

  const dp = new Array(sLen + 1);
  for (let i = 0; i < dp.length; i++) {
    dp[i] = new Array(pLen + 1).fill(false); // 将项默认为false
  }
  // base case
  dp[0][0] = true;
  for (let j = 1; j < pLen + 1; j++) {
    if (p[j - 1] == "*") dp[0][j] = dp[0][j - 2];
  }
  // 迭代
  for (let i = 1; i < sLen + 1; i++) {
    for (let j = 1; j < pLen + 1; j++) {

      if (s[i - 1] == p[j - 1] || p[j - 1] == ".") {
        dp[i][j] = dp[i - 1][j - 1];
      } else if (p[j - 1] == "*") {
        if (s[i - 1] == p[j - 2] || p[j - 2] == ".") {
          dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j];
        } else {
          dp[i][j] = dp[i][j - 2];
        }
      }
    }
  }
  return dp[sLen][pLen]; // 长sLen的s串 是否匹配 长pLen的p串
};
```

创建的 `dp` 二维数组规模是 s，p 的长度 + 1，是因为这里的 `dp` 数组表示的意义是 s(0, m) 和 p(0, n) 的匹配情况，也就是 s 中前 m 个字符和 p 中前 n 个字符的匹配情况。最终的答案 s(0, i) 和 p(0, j) 的匹配情况中，i，j为两串的长度，而数组目录从 0 开始，因此 `dp` 数组规模 + 1

将 `dp[0][0]`设为 true，因为两串的前 0 个字符一定匹配

开始二重循环迭代，都从 1 开始是因为 `dp[0][0]`已经有东西了

`s[i - 1] == p[j - 1] || p[j - 1] == "."`判断字符是否相等，如果相等则转化为子问题

不相等则进一步判断 `p[j - 1]`是否为 '\*' ，若为 '\*'，则进一步判断 '\*' 前面的字符是否和 s 中的当前字符匹配。如成功匹配，则将三个子问题的答案作为当前答案；否则转化为去掉 p中当前字符的子问题

不为 '\*'，说明无法匹配，什么都不做即可（`dp` 本来就初始化为 false）

迭代结束后，`dp[sLen][pLen]`就是是否匹配的答案

## 感想

和最长回文子串相比，dp数组的意义不同了。本宝以为，找到dp数组在题目中的意义对于构建整个解法来说很关键，现在仍是苦手